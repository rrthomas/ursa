--- src/grammar/ursa.ohm-bundle.d.ts	2023-12-31 16:03:51.540793741 +0000
+++ src/grammar/ursa.ohm-bundle.d.ts.bak	2023-12-31 16:03:51.096791164 +0000
@@ -4,148 +4,168 @@
 import {
   BaseActionDict,
   Grammar,
-  IterationNode,
-  Node,
-  NonterminalNode,
+  Node as NodeBase,
+  NonterminalNode as NonterminalNodeBase,
   Semantics,
   TerminalNode
 } from 'ohm-js';

-export interface UrsaActionDict<T> extends BaseActionDict<T> {
-  Sequence?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  sc?: (this: NonterminalNode, arg0: IterationNode | NonterminalNode, arg1: NonterminalNode | TerminalNode) => T;
-  maybeCommaParen?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode) => T;
-  maybeCommaBracket?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode) => T;
-  maybeCommaBrace?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode) => T;
-  PrimaryExp_null?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  PrimaryExp_ident?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  PrimaryExp_paren?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
-  PrimaryExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Definition?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  List?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
-  Object?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
-  Map?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
-  KeyValue?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  PropertyExp_property?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  PropertyExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  CallExp_property?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CallExp_call?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  CallExp_property_call?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  CallExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Arguments?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
-  LvalueExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Ifs?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
-  If?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
-  Fn?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: TerminalNode, arg5: NonterminalNode) => T;
-  Loop?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  For?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
-  UnaryExp_not?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  UnaryExp_bitwise_not?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
-  UnaryExp_pos?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
-  UnaryExp_neg?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
-  UnaryExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  ExponentExp_power?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  ExponentExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  ProductExp_times?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  ProductExp_divide?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  ProductExp_mod?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  ProductExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  SumExp_plus?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  SumExp_minus?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  SumExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  CompareExp_eq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CompareExp_neq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CompareExp_lt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CompareExp_leq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CompareExp_gt?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CompareExp_geq?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  CompareExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  BitwiseExp_and?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  BitwiseExp_xor?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  BitwiseExp_or?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  BitwiseExp_lshift?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  BitwiseExp_arshift?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  BitwiseExp_lrshift?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  BitwiseExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  LogicExp_and?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
-  LogicExp_or?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
-  LogicExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  AssignmentExp_ass?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
-  AssignmentExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Exp_break?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
-  Exp_continue?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Exp_return?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
-  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Lets?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  Let?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  Use?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
-  Block?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
-  and?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  break?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  continue?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  else?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  for?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  fn?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  if?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  let?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  loop?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  of?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  or?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  not?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  return?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  use?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  keyword?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  reservedWord?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  ident?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  identName?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
-  identifierStart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
-  identifierPart?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  null?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  bool?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  number_fract?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
-  number_whole?: (this: NonterminalNode, arg0: IterationNode) => T;
-  number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  string?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
-  stringCharacter_nonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  stringCharacter_escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
-  stringCharacter_lineContinuation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  stringCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  lineContinuation?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
-  escapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  characterEscapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  singleEscapeCharacter?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  nonEscapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  escapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
-  hexEscapeSequence?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
-  unicodeEscapeSequence?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
-  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  lineTerminatorSequence?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  literalString?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
-  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  blockComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode) => T;
-  lineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
-  space?: (this: NonterminalNode, arg0: NonterminalNode) => T;
-  spacesNoNL?: (this: NonterminalNode, arg0: IterationNode) => T;
-  whitespace_verticalTab?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  whitespace_formFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  whitespace_noBreakSpace?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  whitespace_byteOrderMark?: (this: NonterminalNode, arg0: TerminalNode) => T;
-  whitespace?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
-  unicodeSpaceSeparator?: (this: NonterminalNode, arg0: TerminalNode) => T;
+interface NodeI<Operations> extends NodeBase {
+  child(idx: number): Node<Operations>;
+  children: Node<Operations>[];
+  asIteration(): IterationNode<Operations>;
 }

-export interface UrsaSemantics extends Semantics {
-  addOperation<T>(name: string, actionDict: UrsaActionDict<T>): this;
-  extendOperation<T>(name: string, actionDict: UrsaActionDict<T>): this;
-  addAttribute<T>(name: string, actionDict: UrsaActionDict<T>): this;
-  extendAttribute<T>(name: string, actionDict: UrsaActionDict<T>): this;
+export type Node<Operations> = NodeI<Operations> & Operations;
+
+export type IterationNode<Operations> = Node<Operations>;
+
+export type NonterminalNode<Operations> = Node<Operations>;
+
+export type ThisNode<Args, Operations> = Node<Operations> & {
+  // Only the `this` of semantics action routines has this member.
+  args: Args;
+};
+
+export interface UrsaActionDict<T, Node, NonterminalNode, IterationNode, ThisNode> extends BaseActionDict<T> {
+  _terminal?: (this: ThisNode) => T;
+  _nonterminal?: (this: ThisNode, ...children: NonterminalNode[]) => T;
+  _iter?: (this: ThisNode, ...children: NonterminalNode[]) => T;
+  Sequence?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  sc?: (this: ThisNode, arg0: IterationNode | NonterminalNode, arg1: NonterminalNode | TerminalNode) => T;
+  maybeCommaParen?: (this: ThisNode, arg0: IterationNode, arg1: TerminalNode) => T;
+  maybeCommaBracket?: (this: ThisNode, arg0: IterationNode, arg1: TerminalNode) => T;
+  maybeCommaBrace?: (this: ThisNode, arg0: IterationNode, arg1: TerminalNode) => T;
+  PrimaryExp_null?: (this: ThisNode, arg0: NonterminalNode) => T;
+  PrimaryExp_ident?: (this: ThisNode, arg0: NonterminalNode) => T;
+  PrimaryExp_paren?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
+  PrimaryExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Definition?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  List?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
+  Object?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
+  Map?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
+  KeyValue?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  PropertyExp_property?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  PropertyExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  CallExp_property?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CallExp_call?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  CallExp_property_call?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  CallExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Arguments?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
+  LvalueExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Ifs?: (this: ThisNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
+  If?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
+  Fn?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: TerminalNode, arg5: NonterminalNode) => T;
+  Loop?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  For?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
+  UnaryExp_not?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  UnaryExp_bitwise_not?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
+  UnaryExp_pos?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
+  UnaryExp_neg?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
+  UnaryExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  ExponentExp_power?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  ExponentExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  ProductExp_times?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  ProductExp_divide?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  ProductExp_mod?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  ProductExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  SumExp_plus?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  SumExp_minus?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  SumExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  CompareExp_eq?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CompareExp_neq?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CompareExp_lt?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CompareExp_leq?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CompareExp_gt?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CompareExp_geq?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  CompareExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  BitwiseExp_and?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  BitwiseExp_xor?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  BitwiseExp_or?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  BitwiseExp_lshift?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  BitwiseExp_arshift?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  BitwiseExp_lrshift?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  BitwiseExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  LogicExp_and?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
+  LogicExp_or?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
+  LogicExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  AssignmentExp_ass?: (this: ThisNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
+  AssignmentExp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Exp_break?: (this: ThisNode, arg0: NonterminalNode, arg1: IterationNode) => T;
+  Exp_continue?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Exp_return?: (this: ThisNode, arg0: NonterminalNode, arg1: IterationNode) => T;
+  Exp?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Lets?: (this: ThisNode, arg0: NonterminalNode) => T;
+  Let?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  Use?: (this: ThisNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
+  Block?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
+  and?: (this: ThisNode, arg0: TerminalNode) => T;
+  break?: (this: ThisNode, arg0: TerminalNode) => T;
+  continue?: (this: ThisNode, arg0: TerminalNode) => T;
+  else?: (this: ThisNode, arg0: TerminalNode) => T;
+  for?: (this: ThisNode, arg0: TerminalNode) => T;
+  fn?: (this: ThisNode, arg0: TerminalNode) => T;
+  if?: (this: ThisNode, arg0: TerminalNode) => T;
+  let?: (this: ThisNode, arg0: TerminalNode) => T;
+  loop?: (this: ThisNode, arg0: TerminalNode) => T;
+  of?: (this: ThisNode, arg0: TerminalNode) => T;
+  or?: (this: ThisNode, arg0: TerminalNode) => T;
+  not?: (this: ThisNode, arg0: TerminalNode) => T;
+  return?: (this: ThisNode, arg0: TerminalNode) => T;
+  use?: (this: ThisNode, arg0: TerminalNode) => T;
+  keyword?: (this: ThisNode, arg0: NonterminalNode) => T;
+  reservedWord?: (this: ThisNode, arg0: NonterminalNode) => T;
+  ident?: (this: ThisNode, arg0: NonterminalNode) => T;
+  identName?: (this: ThisNode, arg0: NonterminalNode, arg1: IterationNode) => T;
+  identifierStart?: (this: ThisNode, arg0: NonterminalNode | TerminalNode) => T;
+  identifierPart?: (this: ThisNode, arg0: NonterminalNode) => T;
+  null?: (this: ThisNode, arg0: TerminalNode) => T;
+  bool?: (this: ThisNode, arg0: TerminalNode) => T;
+  number_fract?: (this: ThisNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
+  number_whole?: (this: ThisNode, arg0: IterationNode) => T;
+  number?: (this: ThisNode, arg0: NonterminalNode) => T;
+  string?: (this: ThisNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
+  stringCharacter_nonEscaped?: (this: ThisNode, arg0: NonterminalNode) => T;
+  stringCharacter_escaped?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
+  stringCharacter_lineContinuation?: (this: ThisNode, arg0: NonterminalNode) => T;
+  stringCharacter?: (this: ThisNode, arg0: NonterminalNode) => T;
+  lineContinuation?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
+  escapeSequence?: (this: ThisNode, arg0: NonterminalNode) => T;
+  characterEscapeSequence?: (this: ThisNode, arg0: NonterminalNode) => T;
+  singleEscapeCharacter?: (this: ThisNode, arg0: TerminalNode) => T;
+  nonEscapeCharacter?: (this: ThisNode, arg0: NonterminalNode) => T;
+  escapeCharacter?: (this: ThisNode, arg0: NonterminalNode | TerminalNode) => T;
+  hexEscapeSequence?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
+  unicodeEscapeSequence?: (this: ThisNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
+  lineTerminator?: (this: ThisNode, arg0: TerminalNode) => T;
+  lineTerminatorSequence?: (this: ThisNode, arg0: TerminalNode) => T;
+  literalString?: (this: ThisNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
+  comment?: (this: ThisNode, arg0: NonterminalNode) => T;
+  blockComment?: (this: ThisNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode) => T;
+  lineComment?: (this: ThisNode, arg0: TerminalNode, arg1: IterationNode) => T;
+  space?: (this: ThisNode, arg0: NonterminalNode) => T;
+  spacesNoNL?: (this: ThisNode, arg0: IterationNode) => T;
+  whitespace_verticalTab?: (this: ThisNode, arg0: TerminalNode) => T;
+  whitespace_formFeed?: (this: ThisNode, arg0: TerminalNode) => T;
+  whitespace_noBreakSpace?: (this: ThisNode, arg0: TerminalNode) => T;
+  whitespace_byteOrderMark?: (this: ThisNode, arg0: TerminalNode) => T;
+  whitespace?: (this: ThisNode, arg0: NonterminalNode | TerminalNode) => T;
+  unicodeSpaceSeparator?: (this: ThisNode, arg0: TerminalNode) => T;
 }

+interface UrsaSemanticsI<Node, NonterminalNode, IterationNode, ThisNode, Operations> extends Semantics {
+  (match: MatchResult): Operations;
+  addOperation<T>(name: string, actionDict: UrsaActionDict<T, Node, NonterminalNode, IterationNode, ThisNode>): this;
+  extendOperation<T>(name: string, actionDict: UrsaActionDict<T, Node, NonterminalNode, IterationNode, ThisNode>): this;
+  addAttribute<T>(name: string, actionDict: UrsaActionDict<T, Node, NonterminalNode, IterationNode, ThisNode>): this;
+  extendAttribute<T>(name: string, actionDict: UrsaActionDict<T, Node, NonterminalNode, IterationNode, ThisNode>): this;
+}
+export type UrsaSemantics<Node, NonterminalNode, IterationNode, ThisNode, Operations> = UrsaSemanticsI<Node, NonterminalNode, IterationNode, ThisNode, Operations> & Operations;
+
 export interface UrsaGrammar extends Grammar {
-  createSemantics(): UrsaSemantics;
-  extendSemantics(superSemantics: UrsaSemantics): UrsaSemantics;
+  createSemantics<Node, NonterminalNode, IterationNode, ThisNode, Operations>(): UrsaSemantics<Node, NonterminalNode, IterationNode, ThisNode, Operations>;
+  extendSemantics<Node, NonterminalNode, IterationNode, ThisNode, Operations>(superSemantics: UrsaSemantics<Node, NonterminalNode, IterationNode, ThisNode, Operations>): UrsaSemantics<Node, NonterminalNode, IterationNode, ThisNode, Operations>;
 }

 declare const grammar: UrsaGrammar;
 export default grammar;
-
